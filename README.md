# Ignite


## Prezentarea Proiectului
Ignite este aplicația care te ajută să găsești idei pentru a-ți petrece timpul liber, în funcție de cum te simți. Pe baza răspunsurilor din cadrul unui quiz ce iau în calcul bateria ta socială, cât de activ fizic dorești să fii și care este bugetul tău, și totodată luănd în considerare și vremea de afară, primești recomandări asupra activităților pe care le poți face din confortul casei tale sau ieșind în oraș. Mai mult, dacă dorești, îți poți invita prietenii la activități sau poți vedea cum se distrează ei în timpul liber.

Ignite your good mood, ignite your free time!


## User Stories
 **User Story 1** (Studentă la Arhitectură, București, anul I): „M-am mutat de curând în București și mi-ar plăcea să descopăr mai bine orașul. Totuși, în afară de Centrul Vechi și de câteva muzee mai cunoscute, nu știu unde să-mi petrec timpul. A devenit monoton să merg doar în acele locuri și să fac mereu aceleași lucruri! Cred că o aplicație sau un site care să îmi dea sugestii de activități și unde pot să le desfășor ar fi binevenită!”

 **User Story 2** (Student la Arte, Cluj, anul II): „Acum că s-au ridicat restricțiile doresc să mă conectez mai profund cu prietenii mei și să ne petrecem timpul împreună mai mult. Aș vrea să îi pot invita la tot felul de activități mai interesante și să le transmit mai ușor informațiile despre locurile și evenimentele la care mergem. ”

 **User Story 3** (licean, Timișoara, clasa a X-a): „Toți prietenii mei au iPhone și astfel au Find My Friends. Sunt singurul care nu știe unde îi sunt prietenii. Astfel, mi-ar plăcea o aplicație unde pot să văd unde sunt și ce fac prietenii mei, ca să nu mă mai simt exclus din propriul grup de prieteni. Totuși, ca să îmi conving prietenii să își instaleze aplicația, ar trebui să aibă ceva în plus…”

 **User Story 4** (Creatoare de Conținut, București): „Majoritatea conținutului meu este filmat afară. Așadar, de fiecare dată când ies afară, trebuie să utilizez o sumedenie de aplicații precum cea pentru vreme sau cea de hărți ca să știu unde trebuie să ajung. Trebuie să fac research de activități și locuri unde le pot face ca să pot crea materiale cât mai diverse. Mai mult, mai trebuie să mă mai uit și la ceas și la dată. Dacă ar exista o aplicație care să cuprindă toate aceste aspecte, nu numai că aș folosi-o, aș și promova-o pe platformele mele! ”

 **User Story 5** (Studentă la Film, Berlin, anul I): „Toată ziua fug prin tot Berlinul: ba la facultate, ba pe la diferite platouri de filmare. Când ajung seara acasă sunt foarte obosită, însă uneori doresc să fac diferite lucruri, nu să pierd timpul. Uneori sunt așa obosită încât nici nu îmi vine să mă gândesc la ce pot face. Mi-ar plăcea să existe o aplicație care să îmi recomande ce pot face acasă, în funcție de starea mea de spirit. ”

 **User Story 6** (Programator, Bruxelles): „Observ că foarte multă lume își îndreaptă atenția către tehnologie, dar și către a se relaxa deopotrivă acasă sau afară. O aplicație care le îmbină pe amândouă chiar cred că ar fi primită cu brațele deschise. Însă cred că trebuie să rămână o aplicație simplă, minimalistă și user-friendly! Văd că în ultimul timp există un val de aplicații care au foarte multe reclame, culori stridente și sunt extrem de haotice, și de aceea nu au mai deloc utilizatori.”

 **User Story 7** (Social Media Manager, Londra): „Sunt o persoană nehotărâtă! Deși sunt o fire sociabilă și vreau o viață activă, uneori ajung să nu ies din casă întocmai pentru că nu mă pot hotărî ce vreau să fac. Locuiesc într-un oraș atât de frumos în care poți să ieși seară de seară și să descoperi locuri noi, dar întocmai pentru că nu știu ce să aleg ajung să nu mai descopăr niciunul dintre aceste locuri. Așadar, cea mai mare plăcere a mea când folosesc aplicația este să fac quiz-ul. E unul scurt, dar cuprinzător, și de fiecare dată îmi recomandă ce să fac fără să trebuiască să aleg eu.

 **User Story 8** (Studentă la Drept, București, Anul III): „Fiind studentă și locuind la cămin, nu am la dispoziție nici atât de mulți bani ca să mă duc în locuri foarte scumpe, nici nu am loc de foarte multe cărți de beletristică, instrumente muzicale sau alte lucruri de genul la mine în cameră. Astfel, de fiecare dată când aplicația îmi recomandă să citesc ceva, să mă duc la un restaurant scump sau să pictez, nu am la îndemână și nici nu îmi permit să achiziționez toate materialele necesare sau să merg acolo. De aceea, aș recomanda crearea unui buton de refresh care pe baza quiz-ului pe care îl completezi să îți ofere alte sugestii, pentru că astfel poate voi găsi mai ușor activități potrivite mie.”

 **User Story 9** (Travel Influencer, Varșovia): „Călătorind mult și având mulți prieteni din toate colțurie lumii, nu folosim toți aceleași unități de măsură a temperaturii. Devine enervant să mă gândesc mereu dacă să le spun temperatura în Celsius sau Fahrenheit când ne întâlnim. Mi-ar plăcea de la o aplicație să aibă mai multe unități de măsură.”

 **User Story 10** (Professional gamer): „Fiind nevoit să petrec atât de mult timp în fața calculatorului, am nevoie de ceva care să mă deconecteze. Însă mă plictisesc repede și aș avea nevoie și de ceva care să mă facă să intru mai des pe aplicație, poate chiar și un reward ca să mă laud în fața prietenilor, spre exemplu ceva asemănător cu streak-urile de la jocuri.”
 
 
 ## Backlog creation
 
 Pentru backlog am utilizat Jira.
 ![image](https://user-images.githubusercontent.com/79279298/173641082-c8653e2f-1335-4e3c-9da2-144faf6974dd.png)

 
## Diagramă UML
 
![uml drawio](https://user-images.githubusercontent.com/79279298/171692554-9e6a2869-ef6d-42e0-9d44-2e4c34c670a9.png)

## Diagramă ERD
![erd drawio](https://i.imgur.com/ycKPYAJ.png)


## Source control
### Branch creation
Branch-urile create de noi pot fi [găsite aici](https://github.com/MadalinaKopacz/Ignite/branches).
Am utilizat 4 branch-uri, Main ca branch default și câte un branch pentru fiecare membru al echipei pentru a putea monotoriza activitatea fiecărui

### Merge
Merge-urile pot fi observate [aici](https://github.com/MadalinaKopacz/Ignite/pulls?q=is%3Apr+is%3Aclosed), în cadrul pull requesturilor închise.

### Commits
Commiturile se află [aici](https://github.com/MadalinaKopacz/Ignite/commits/main).


## Teste automate
Avem un total de 8 teste automate de tip unit, implementate prin întermediul claselor:
1. AccountsTest

   ```
   class AccountsTest(TestCase):
    def setUp(self):
        test_user1 = User.objects.create_user(username='testuser1', password='1X<ISRUkw+tuK')
        test_user1.save()

    def test_logged_in_uses_correct_template(self):
        login = self.client.login(username='testuser1', password='1X<ISRUkw+tuK')
        response = self.client.get(reverse('start_page:get_start_page'))

        self.assertEqual(str(response.context['user']), 'testuser1')
        self.assertEqual(response.status_code, 200)
        self.assertTemplateUsed(response, 'global/start_page.html')
    ```

    Prin intermediul metodei `test_logged_in_uses_correct_template` am testat dacă aplicația nu are erori la logarea unui user și dacă utilizează template-ul corect.


2. ActivitiesModelsTest

    ```
    class ActivitiesModelsTest(TestCase):
    @classmethod
    def setUpTestData(cls):
        Activity.objects.create(name = 'reading a book?', description = 'Choose a book from your library and read it!', location = 'at home', location_type = 'indoor', lon = 0, lat = 0)
        

    def test_name_label(self):
        activity = Activity.objects.get(id =1)
        field_label = activity._meta.get_field('name').verbose_name
        self.assertEqual(field_label, 'name')
    
    def test_location_type_default(self):
        activity = Activity.objects.get(id =1)
        value = activity._meta.get_field('location_type').default
        self.assertEqual(value, 'any')

    def test_lon_max_lenght(self):
        activity = Activity.objects.get(id=1)
        max_length = activity._meta.get_field('lon').max_digits
        self.assertEqual(max_length, 10)
    ```

    În cadrul acestei clase am testat corectitudinea implementării modelului Activities. Prin intermediul metodei `test_name_label` am testat dacă labelul corespunzător câmpului "name" este corect. În cadrul `test_location_type_default` am verificat ca valoarea default a câmpului location_type să fie mereu "any". Prin `test_lon_max_lenght` verificăm ca numărul maxim de cifre pe care îl pot avea valorile câmpului `lon` să fie maxim 10.


3. QuizTest

   ```
   class QuizTest(TestCase):
    @classmethod
    def setUpTestData(cls):
        for q_id in range(10):
            Question.objects.create(title=f'{q_id}',text=f'Text {q_id}',qtype = q_id%3+1)


    def test_qtype_options(self):
        form = QuestionCreateForm()
        choices = form.fields['qtype'].choices
        self.assertEqual(choices, [('', '---------'), (1, 'Social'), (2, 'Physical'), (3, 'Money')])
        
    def test_text_max_length(self):
        textTest = 'a'*301
        form = QuestionCreateForm(data={'qtype': 1, 'text': textTest})
        self.assertFalse(form.is_valid())
        textTest = 'a'*300
        form1 = QuestionCreateForm(data={'qtype': 1, 'text': textTest})
        self.assertTrue(form1.is_valid())
        textTest = 'a'*150
        form2 = QuestionCreateForm(data={'qtype': 1, 'text': textTest})
        self.assertTrue(form2.is_valid())


    def test_view_url_exists_at_desired_location(self):
        response = self.client.get('/mood_quizzes/createQuestion/')
        self.assertEqual(response.status_code, 200)

    def test_view_uses_correct_template(self):
        response = self.client.get(reverse('mood_quizzes:quiz'))
        self.assertEqual(response.status_code, 200)
        self.assertTemplateUsed(response, 'quizzes/quiz.html')
   
   ```
        
   În cadrul acestei clase am testat corectitudinea implementării formularului și a view-urilor. Prin intermediul `test_qtype_options` verificăm ca formularul să aibă pentru itemul qtype câmpul vid în cazul în care nicio opțiune nu a fost aleasă și cele trei opțiuni ale tipurilor de întrebări ('Social', Physical' și 'Money'). În cadrul `test_text_max_length` testăm ca șirurile de caractere primite în cadrul itemului textt din formular să nu aiba mai mult de 300 de caractere. `test_view_url_exists_at_desired_location` testează ca url-ul formularului de creare de întrebări să fie la locația dorită, iar `test_view_uses_correct_template` testează corectitudinea template-ului folosit.
   
   
   Rularea testelor se face prin comanda `python manage.py test` scrisă în terminal, iar rezultatul acesteia în cadrul proiectului nostru este:
   ![image](https://user-images.githubusercontent.com/79279298/173663150-090ccf3e-825e-4f73-82c4-18c94ef42384.png)


## Bug reporting

1. Variabilele din context în Django sunt date ca șiruri de caractere, iar în funcția de inițializare a hărții unde aveam nevoie de valorile longitudinii și latitudinii ca numere reale, preluam variabilele din context fără conversie, rezultând într-un bug. Pentru a rezolva problema am făcut conversie la float.

2. Pagina de Login redirectiona la pagina de create user (Signup), iar cea de Logout redirectiona inapoi de Login în loc de prima pagină (cu Login/Signup). Pentru a rezolva bugul, am schimbat login url-ul și redirecționările. 


## Build tool

Pentru a crea proiectul am utilizat comanda `django-admin startproject ignite` în terminal. Această comandă creează un director care conține fișierul manage.py și un director care conține fișierul de inițializare și fișierele settings.py, urls.py, asgi.py și wsgi.py. Pentru a crea fiecare app am folosit comenzi precum `python manage.py startapp accounts` care creează câte un director pentru fiecare app, conținănd fișierul de inițializare, apps.py, folderul de migrations și fișierele models.py, tests.py și views.py. 

Mai mult, am utilizat și venv ca virtual environment pentru a putea ține evidența librăriilor pe care le-am utilizat.


## Refactoring & Code standards


## Design patterns

Am utilizat design patternul Model-View-Template (MVT) specific Djangoului. Modelele gestionează datele și este reprezentată de baza noastră de date, un model reprezentând o tabelă din baza de date. Un view primește cereri HTTP și trimite răspuri HTML, interacționând cu un model și un template pentru a finaliza un răspuns. Template-ul conține componenta HTML-ul dinamică a aplicației. 
